# 🧩 **【题型：PHAR 反序列化 + SSRF 多阶段链】**

---

## **定义**

利用 PHP 的 `phar://` 流包装器结合 `unserialize` 触发对象反序列化执行。
在 实战中，通常为两阶段链：外网上传 PHAR → 内网容器触发 PHAR 执行 → 回显 flag。可结合 SSRF 发起内部请求。

---

## **1. 题目类型**

* PHP `unserialize` 反序列化漏洞 + PHAR 流
* SSRF / 内网请求触发
* 多阶段链（外网 PHAR → 内网 PHAR → flag 回显）

---

## **2. 解题输出思路**

1. 构造第 1 阶段 PHAR：

   * 包含 `manifest` 文件
   * `manifest` 内序列化 `CustomTemplate` 对象
   * `data` 字段内嵌触发内网 SSRF / 上传第 2 阶段 PHAR 的 PHP 代码
2. 上传第 1 阶段 PHAR 到外网可写路径（如 `/tmp/<hash>.jpg`）
3. 利用第 1 阶段 PHAR 发起 SSRF 请求，上传并触发第 2 阶段 PHAR 至内网 `skumodel` 容器
4. 第 2 阶段 PHAR 执行：

   * 读取内网 flag（`/flag.txt`）
   * 输出到 JSON 返回字段
5. 从外网第 1 阶段获取 JSON，提取 `output` 即 flag

---

## **3. 关注点**

* PHP 是否启用 `phar://` 流包装器
* 目标服务是否可写并可触发 `unserialize`
* 内网容器是否能被 SSRF 请求触发
* PHAR 内序列化对象链是否正确（`CustomTemplate` 或自定义可执行类）
* 数据编码格式（中 base64 编码用于上传和触发）

---

## **4. 通用**

### 通用步骤

* 构造可触发反序列化的 PHAR：

  * 设置 `manifest` 文件
  * 序列化目标对象（含 payload）
* 上传 PHAR 文件到目标服务
* 利用 `phar://` 流触发 `unserialize`
* 获取回显结果（flag / shell / JSON 输出）

---

## **5. 方法论**

1. **PHAR 构造法**

   * 利用 `phar://` 文件头 + 序列化对象触发反序列化链
2. **多阶段 SSRF 联动**

   * 外网 PHAR 作为跳板
   * 内网 PHAR 执行敏感操作
   * 回显 flag 或执行 RCE
3. **自动化脚本辅助**

   * 提供示例脚本，将 Base64 PHAR 上传、触发并解析返回 JSON

---

## **6. 启发性问题**

* 外网可上传路径是否可触发 `phar://`？
* 内网服务可否通过 SSRF 被访问？
* 第 1 阶段 PHAR 是否可携带序列化对象 payload？
* 是否需要对 Base64 或二进制进行编码解码处理？

---

## **7. 绕过技巧**

* 使用 Base64 封装 PHAR 文件，防止上传时被修改
* 利用 manifest 文件嵌入多阶段逻辑
* SSRF 自动触发内网 PHAR 执行
* 序列化对象链设计必须兼容外网 → 内网容器类加载

---