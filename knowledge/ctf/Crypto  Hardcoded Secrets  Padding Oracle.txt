## **B. Crypto Hardcoded Secrets Padding Oracle**

### 1. 类型

* Padding Oracle 攻击（CBC 模式）
* 硬编码密钥/IV
* AES-CBC 解密泄露

### 2. 解题输出思路

1. 分析加密算法和模式（通常是 AES-CBC）
2. 检查是否存在硬编码的密钥或 IV
3. 确认 Padding 验证逻辑（Oracle）
4. 实现 Padding Oracle 攻击脚本
5. 解密密文获取 flag 或其他密钥
6. 若存在硬编码密钥，直接解密

### 3. 关注点

* 加密模式（CBC、ECB 等）
* Padding 方式（PKCS#7）
* Oracle 响应差异（时间、状态码、错误信息）
* 密钥和 IV 的来源（硬编码、环境变量、配置文件）
* 加密/解密函数的实现细节

### 4. 通用

#### 通用步骤

* 确认加密/解密函数的 Oracle 行为
* 测试不同长度的密文响应
* 实现 CBC 加密/解密逻辑

### 5. 方法论

* 利用 Padding 验证的布尔反馈
* 通过修改密文块爆破明文块
* 流程：Oracle 识别 → 脚本编写 → 逐块解密 → flag 重构

### 6. 启发性问题

* 解密函数是否区分 Padding 错误和其他错误？
* 是否存在时间差异？
* 密钥是否硬编码在源码中？
* 是否可以控制 IV？

### 7. 绕过技巧

* 利用时间差异进行 Oracle 判断
* 处理不同的错误响应码
* 处理响应内容差异

### 8. 典型 payload

#### Padding Oracle 解密脚本核心逻辑（Python）：

```python
def decrypt_block(oracle, ciphertext_block, previous_ciphertext_block):
    block_size = 16
    decrypted_block = [0] * block_size
    intermediate_values = [0] * block_size

    for i in range(block_size - 1, -1, -1):
        padding_value = block_size - i
        for byte_val in range(0, 256):
            # 构造测试密文块
            test_block = bytearray(block_size)
            for k in range(i + 1, block_size):
                test_block[k] = previous_ciphertext_block[k] ^ padding_value ^ intermediate_values[k]
            test_block[i] = byte_val

            # 调用 Oracle
            if oracle(test_block + ciphertext_block):
                intermediate_values[i] = byte_val ^ padding_value
                decrypted_block[i] = previous_ciphertext_block[i] ^ intermediate_values[i]
                break

    return bytes(decrypted_block)
```

#### 硬编码密钥解密：

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

key = b'hardcoded_key_16' # 从源码中找到
iv = b'hardcoded_iv_16_'
ciphertext = bytes.fromhex('...') # 获取的密文

cipher = AES.new(key, AES.MODE_CBC, iv)
plaintext = unpad(cipher.decrypt(ciphertext), AES.block_size)
print(plaintext.decode())
```
